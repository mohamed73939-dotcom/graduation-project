# -------------------- Improved frontend/app.py (Streamlit) --------------------
# RATIONALE:
# - Professionalized the UI with sections and feedback.
# - Added API_URL configuration (sidebar), defaults to http://localhost:8000.
# - Uses language 'auto' by default to leverage backend language detection.
# - Displays detected language, confidence, latency, and chunk metadata.
# - Better error handling and user-friendly messages.
# - Ensures correct multipart form submission and handles large files gracefully.

import os
import json
import time
import requests
import streamlit as st

st.set_page_config(
    page_title="Sidecut - AI Video Summarizer",
    page_icon="âœ‚ï¸",
    layout="wide"
)

st.title("âœ‚ï¸ Sidecut - ØªÙ„Ø®ÙŠØµ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ")
st.caption("ØªÙ„Ø®ÙŠØµ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§ØªÙƒ Ø¨Ø¯Ù‚Ø© ÙˆØ¯Ø¹Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ÙˆØ§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©")
st.markdown("---")

# Sidebar settings
with st.sidebar:
    st.header("âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª")
    default_api = os.getenv("SIDECUT_API_URL", "http://localhost:8000")
    api_url = st.text_input("API URL", value=default_api, help="Ù…Ø«Ø§Ù„: http://localhost:8000")
    language = st.selectbox(
        "Ù„ØºØ© Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø©",
        ["auto", "ar", "en"],
        index=0,
        format_func=lambda x: {"ar": "ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", "en": "ğŸ‡¬ğŸ‡§ English", "auto": "ğŸŒ Ø§ÙƒØªØ´Ø§Ù ØªÙ„Ù‚Ø§Ø¦ÙŠ"}[x]
    )
    st.markdown("---")
    st.info("ğŸ’¡ Ù…Ù„Ø§Ø­Ø¸Ø©: Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„Ø£ØµØºØ± Ù…Ù† 100MB ØªÙØ¹Ø§Ù„Ø¬ Ø£Ø³Ø±Ø¹. Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 500MB.")
    st.markdown("---")
    st.write("Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ù…Ø­ÙÙˆØ¸Ø© ÙÙŠ Ù…Ø¬Ù„Ø¯ logs/")

# Upload
uploaded_file = st.file_uploader("ğŸ“¤ Ø§Ø±ÙØ¹ Ù…Ù„Ù Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (MP4, AVI, MOV, MKV, WEBM)", type=["mp4", "avi", "mov", "mkv", "webm"])

# UI helpers
def _show_result_section(result_data):
    # Core fields returned by backend
    summary = result_data.get("summary", "")
    transcription = result_data.get("transcription", "")
    detected_language = result_data.get("detected_language", "unknown")
    confidence = result_data.get("confidence", {})
    metrics = result_data.get("metrics", {})
    chunk_meta = result_data.get("chunk_metadata", [])

    st.success("âœ… ØªÙ… Ø§Ù„ØªÙ„Ø®ÙŠØµ Ø¨Ù†Ø¬Ø§Ø­!")

    # Summary section
    st.subheader("ğŸ“ Ø§Ù„Ù…Ù„Ø®Øµ")
    # Direction awareness: Right-to-left for Arabic
    text_direction = "rtl" if detected_language == "ar" else "ltr"
    st.markdown(
        f'<div style="direction:{text_direction}; text-align:{ "right" if text_direction=="rtl" else "left" };">{summary}</div>',
        unsafe_allow_html=True,
    )

    # Download button
    st.download_button(
        label="â¬‡ï¸ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ø®Øµ (TXT)",
        data=summary or "",
        file_name=f"summary.txt",
        mime="text/plain"
    )

    # Metadata
    col1, col2 = st.columns(2)
    with col1:
        st.metric("Ø§Ù„Ù„ØºØ© Ø§Ù„Ù…ÙƒØªØ´ÙØ©", detected_language.upper())
    with col2:
        st.metric("Ø§Ù„Ù…Ø¯Ø© (Ø«ÙˆØ§Ù†ÙŠ)", f'{metrics.get("latency_seconds", 0.0):.2f}')

    # Transcription preview
    with st.expander("ğŸ“„ Ø§Ù„Ù†Øµ Ø§Ù„ÙƒØ§Ù…Ù„ (Ù…Ø¹Ø§ÙŠÙ†Ø©)"):
        st.text(transcription)

    # Chunk diagnostics
    with st.expander("ğŸ” ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ù‚Ø§Ø·Ø¹ (Chunks)"):
        if chunk_meta:
            st.write(f"Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù‚Ø§Ø·Ø¹: {len(chunk_meta)}")
            st.dataframe(chunk_meta)
        else:
            st.write("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù‚Ø§Ø·Ø¹ Ù…ØªØ§Ø­Ø©.")

# Main action
if uploaded_file:
    col1, col2 = st.columns([2, 1])
    with col1:
        st.video(uploaded_file)
    with col2:
        st.info(f"**Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù:** {uploaded_file.name}")
        st.info(f"**Ø§Ù„Ø­Ø¬Ù…:** {uploaded_file.size / (1024*1024):.2f} MB")

        if st.button("ğŸš€ Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªÙ„Ø®ÙŠØµ", use_container_width=True):
            if not api_url:
                st.error("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ API URL ØµØ­ÙŠØ­.")
            else:
                with st.spinner("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©... Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ Ø°Ù„Ùƒ Ø¨Ø¹Ø¶ Ø§Ù„ÙˆÙ‚Øª Ø­Ø³Ø¨ Ø·ÙˆÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙˆØ§Ù„Ù…ÙˆØ¯ÙŠÙ„"):
                    try:
                        # Important: pass the file as a tuple of (filename, file object, mimetype)
                        files = {"video": (uploaded_file.name, uploaded_file, uploaded_file.type)}
                        data = {"language": language}
                        resp = requests.post(f"{api_url.rstrip('/')}/api/summarize", files=files, data=data, timeout=3600)
                        if resp.status_code == 200:
                            payload = resp.json()
                            if payload.get("status") == "success":
                                _show_result_section(payload["data"])
                            else:
                                st.error(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {payload.get('message', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}")
                        else:
                            # Try to show server message if present
                            try:
                                err = resp.json()
                                st.error(f"âŒ Ø®Ø·Ø£: {err.get('message', resp.text)}")
                            except Exception:
                                st.error(f"âŒ Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: {resp.text}")
                    except requests.exceptions.RequestException as e:
                        st.error(f"âŒ ØªØ¹Ø°Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…: {e}")
else:
    st.info("ğŸ‘† Ù‚Ù… Ø¨Ø±ÙØ¹ Ù…Ù„Ù ÙÙŠØ¯ÙŠÙˆ Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªÙ„Ø®ÙŠØµ.")

# Footer
st.markdown("---")
st.caption("Â© 2025 Sidecut â€” Ù…ÙØªÙˆØ­ Ø§Ù„Ù…ØµØ¯Ø±. Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ø±Ø§Ø¬Ø¹ Ø§Ù„ÙˆØ«Ø§Ø¦Ù‚ ÙÙŠ README.md.")